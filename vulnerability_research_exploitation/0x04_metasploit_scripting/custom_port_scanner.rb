#!/usr/bin/env ruby
# frozen_string_literal: true

require 'msf/core'

# A custom metesploit module
# Scans a range of ports on a target IP address
class MetasploitModule < Msf::Auxiliary
  include Msf::Exploit::Remote::Tcp

  def initialize(info = {})
    super(
      update_info(
        info,
        'name' => 'testmodule',
        'Description' => 'A custom port scan module',
        'Author' => 'Solo',
        'License' => MSF_LICENSE
      )
    )

    register_options(
      [
        OptAddress.new('RHOST', [true, 'The target IP address or range']),
        OptInt.new('STARTPORT', [true, 'The starting port number', 1]),
        OptInt.new('ENDPORT', [true, 'The ending port number', 65_535]),
        OptPort.new('RPORT', [false, 'not required'])
      ]
    )
  end

  # Validate that the start port is not greater than the end port
  def validate_ports(startport, endport)
    return true if startport <= endport

    print_error('[-] starting port must not be greater than ending port')
    false
  end

  # Scan the specified range of ports
  def scan_ports(rhost, startport, endport)
    my_list =[] 
    print_good("[*] Running module against #{rhost}")
    (startport..endport).each do |port|
      begin
        datastore['RPORT'] = port
        connect
        print_good("#{rhost}:#{port} - Port #{port} is open on #{rhost}")
        my_list.append(port)
      rescue Rex::ConnectionError
        nil
      ensure
        disconnect
      end
    end
    print_good("Open ports on #{rhost}: #{my_list.join(', ')}")
  end

  def run
    rhost = datastore['RHOST']
    startport = datastore['STARTPORT']
    endport = datastore['ENDPORT']

    return unless validate_ports(startport, endport)

    scan_ports(rhost, startport, endport)
  end
end
